        
        <link rel="stylesheet" href="../static/markdown_editor.css">

        <!-- Toolbar -->
        <div class="toolbar">
            <!-- Formatting Group -->
            <div class="toolbar-group">
                <div class="dropdown">
                    <button class="toolbar-btn" id="headingBtn">
                        <span>H</span> ‚ñº
                    </button>
                    <div class="dropdown-content" id="headingDropdown">
                        <div class="dropdown-item" data-action="heading" data-level="1">Heading 1</div>
                        <div class="dropdown-item" data-action="heading" data-level="2">Heading 2</div>
                        <div class="dropdown-item" data-action="heading" data-level="3">Heading 3</div>
                        <div class="dropdown-item" data-action="heading" data-level="4">Heading 4</div>
                        <div class="dropdown-item" data-action="heading" data-level="5">Heading 5</div>
                        <div class="dropdown-item" data-action="heading" data-level="6">Heading 6</div>
                    </div>
                </div>
                <button class="toolbar-btn" data-action="bold" title="Bold (Ctrl+B)">
                    <strong>B</strong>
                </button>
                <button class="toolbar-btn" data-action="italic" title="Italic (Ctrl+I)">
                    <em>I</em>
                </button>
                <button class="toolbar-btn" data-action="strikethrough" title="Strikethrough">
                    <s>S</s>
                </button>
            </div>

            <!-- List Group -->
            <div class="toolbar-group">
                <button class="toolbar-btn" data-action="unordered-list" title="Bullet List">
                    ‚Ä¢ List
                </button>
                <button class="toolbar-btn" data-action="ordered-list" title="Numbered List">
                    1. List
                </button>
                <button class="toolbar-btn" data-action="task-list" title="Task List">
                    ‚òë Task
                </button>
            </div>

            <!-- Insert Group -->
            <div class="toolbar-group">
                <button class="toolbar-btn" data-action="link" title="Link">
                    üîó Link
                </button>
                <!-- <button class="toolbar-btn" data-action="image" title="Image">
                    üñºÔ∏è Image
                </button> -->
                <button class="toolbar-btn" data-action="table" title="Table (Ctrl+T)">
                    üìä Table
                </button>
                <button class="toolbar-btn" data-action="code-block" title="Code Block">
                    üíª Code
                </button>
            </div>

            <!-- More Group -->
            <div class="toolbar-group">
                <button class="toolbar-btn" data-action="blockquote" title="Quote">
                    üí¨ Quote
                </button>
                <button class="toolbar-btn" data-action="horizontal-rule" title="Horizontal Rule">
                    ‚ûñ HR
                </button>
                <button class="toolbar-btn" data-action="highlight" title="Highlight">
                    üñçÔ∏è Mark
                </button>
            </div>
        </div>

        <!-- Main Editor -->
        <div class="editor-main">
            <!-- Editor Pane -->
            <div class="editor-pane">
                <div class="pane-header">
                    ‚úèÔ∏è Markdown Editor
                </div>
                <textarea 
                    class="editor-textarea" 
                    id="markdownEditor"
                    placeholder="Start typing your markdown here...

You can always use the editor features from the editor-tab but here are some useful markdown syntax.
Easy to learn, Goes a long way. 

Try these:

<br> space
# Heading 1
## Heading 2
**Bold text**
*Italic text*
- List item
[Link](url)
`inline code`

```javascript
// Code block
console.log('Hello World');
```"
                ></textarea>
            </div>

            <!-- Preview Pane -->
            <div class="preview-pane">
                <div class="pane-header">
                üëÅÔ∏è Live Preview
                </div>
                <div class="preview-content" id="previewContent">
                    <h1>Welcome to Advanced Markdown Editor</h1>
                    <p>Start typing in the editor to see live preview here.</p>
                    <h2>Features</h2>
                    <ul>
                        <li><strong>Real-time preview</strong></li>
                        <li><em>Word-like toolbar</em></li>
                        <li>Full markdown support</li>
                        <li>Tables, code blocks, and more</li>
                    </ul>
                </div>
            </div>
        </div> 

        <!-- Status Bar -->
        <div class="status-bar">
            <div>
                <span id="wordCount">0 words</span> | 
                <span id="charCount">0 characters</span> | 
                <span id="lineCount">1 lines</span>
            </div>
            <div>
                Ready
            </div>
        </div>
    

    <!-- Table Creation Dialog -->
    <div class="table-dialog" id="tableDialog">
        <div class="table-dialog-content">
            <div class="table-dialog-header">
                üìä Insert Table
            </div>
            
            <div class="table-selector" id="tableSelector">
                <!-- Grid cells will be generated by JavaScript -->
            </div>
            
            <div class="table-info" id="tableInfo">
                Select table size (1 √ó 1)
            </div>
            
            <div class="table-inputs">
                <div class="input-group">
                    <label for="rowsInput">Rows</label>
                    <input type="number" id="rowsInput" min="1" max="20" value="3">
                </div>
                <div class="input-group">
                    <label for="colsInput">Columns</label>
                    <input type="number" id="colsInput" min="1" max="20" value="3">
                </div>
            </div>
            
            <div class="table-dialog-actions">
                <button class="dialog-btn dialog-btn-cancel" id="cancelTableBtn">
                    Cancel
                </button>
                <button class="dialog-btn dialog-btn-create" id="createTableBtn">
                    Create Table
                </button>
            </div>
        </div>
    </div>

    <!-- Include marked.js for markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <script>
        class EmbeddedMarkdownEditor {
            constructor() {
                this.editor = document.getElementById('markdownEditor');
                this.preview = document.getElementById('previewContent');
                this.wordCount = document.getElementById('wordCount');
                this.charCount = document.getElementById('charCount');
                this.lineCount = document.getElementById('lineCount');
                
                // Table dialog elements
                this.tableDialog = document.getElementById('tableDialog');
                this.tableSelector = document.getElementById('tableSelector');
                this.tableInfo = document.getElementById('tableInfo');
                this.rowsInput = document.getElementById('rowsInput');
                this.colsInput = document.getElementById('colsInput');
                this.createTableBtn = document.getElementById('createTableBtn');
                this.cancelTableBtn = document.getElementById('cancelTableBtn');
                
                this.selectedRows = 3;
                this.selectedCols = 3;
                
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.setupToolbar();
                this.setupTableDialog();
                this.updatePreview();
                this.updateStats();
                
                // Configure marked for better rendering
                marked.setOptions({
                    breaks: true,
                    gfm: true,
                    highlight: function(code, lang) {
                        return code; // Basic highlighting, can be enhanced
                    }
                });
            }

            setupEventListeners() {
                // Real-time preview update
                this.editor.addEventListener('input', () => {
                    this.updatePreview();
                    this.updateStats();
                });

                // Handle special key combinations
                this.editor.addEventListener('keydown', (e) => {
                    this.handleKeyDown(e);
                });

                // Handle paste events
                this.editor.addEventListener('paste', (e) => {
                    this.handlePaste(e);
                });
            }

            setupToolbar() {
                // Toolbar button clicks
                document.querySelectorAll('.toolbar-btn[data-action]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        const action = btn.getAttribute('data-action');
                        
                        if (action === 'table') {
                            this.showTableDialog();
                        } else {
                            this.executeAction(action, btn);
                        }
                    });
                });

                // Dropdown handling
                const headingBtn = document.getElementById('headingBtn');
                if (headingBtn) {
                    headingBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        this.toggleDropdown('headingDropdown');
                    });
                }

                // Dropdown item clicks
                document.querySelectorAll('.dropdown-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        const action = item.getAttribute('data-action');
                        const level = item.getAttribute('data-level');
                        this.executeAction(action, item, { level });
                        this.hideDropdowns();
                    });
                });

                // Close dropdowns when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.dropdown')) {
                        this.hideDropdowns();
                    }
                });
            }

            setupTableDialog() {
                // Generate table selector grid
                this.generateTableGrid();
                
                // Table selector hover and click events
                this.setupTableSelector();
                
                // Input field events
                this.rowsInput.addEventListener('input', () => {
                    this.updateTableFromInputs();
                });
                
                this.colsInput.addEventListener('input', () => {
                    this.updateTableFromInputs();
                });
                
                // Dialog button events
                this.createTableBtn.addEventListener('click', () => {
                    this.createTableFromDialog();
                });
                
                this.cancelTableBtn.addEventListener('click', () => {
                    this.hideTableDialog();
                });
                
                // Close dialog when clicking outside
                this.tableDialog.addEventListener('click', (e) => {
                    if (e.target === this.tableDialog) {
                        this.hideTableDialog();
                    }
                });
                
                // Close dialog with Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.tableDialog.classList.contains('show')) {
                        this.hideTableDialog();
                    }
                });
            }

            generateTableGrid() {
                this.tableSelector.innerHTML = '';
                
                // Create 10x10 grid
                for (let i = 0; i < 100; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'table-cell';
                    cell.dataset.row = Math.floor(i / 10) + 1;
                    cell.dataset.col = (i % 10) + 1;
                    this.tableSelector.appendChild(cell);
                }
            }

            setupTableSelector() {
                const cells = this.tableSelector.querySelectorAll('.table-cell');
                
                cells.forEach(cell => {
                    cell.addEventListener('mouseenter', (e) => {
                        const row = parseInt(e.target.dataset.row);
                        const col = parseInt(e.target.dataset.col);
                        this.highlightTableCells(row, col);
                        this.updateTableInfo(row, col);
                    });
                    
                    cell.addEventListener('click', (e) => {
                        const row = parseInt(e.target.dataset.row);
                        const col = parseInt(e.target.dataset.col);
                        this.selectTableSize(row, col);
                    });
                });
                
                this.tableSelector.addEventListener('mouseleave', () => {
                    this.clearTableHighlight();
                    this.updateTableInfo(this.selectedRows, this.selectedCols);
                });
            }

            highlightTableCells(rows, cols) {
                const cells = this.tableSelector.querySelectorAll('.table-cell');
                
                cells.forEach(cell => {
                    const cellRow = parseInt(cell.dataset.row);
                    const cellCol = parseInt(cell.dataset.col);
                    
                    cell.classList.remove('selected', 'hover-preview');
                    
                    if (cellRow <= rows && cellCol <= cols) {
                        if (cellRow <= this.selectedRows && cellCol <= this.selectedCols) {
                            cell.classList.add('selected');
                        } else {
                            cell.classList.add('hover-preview');
                        }
                    }
                });
            }

            clearTableHighlight() {
                const cells = this.tableSelector.querySelectorAll('.table-cell');
                cells.forEach(cell => {
                    cell.classList.remove('hover-preview');
                });
                this.highlightSelectedCells();
            }

            highlightSelectedCells() {
                const cells = this.tableSelector.querySelectorAll('.table-cell');
                
                cells.forEach(cell => {
                    const cellRow = parseInt(cell.dataset.row);
                    const cellCol = parseInt(cell.dataset.col);
                    
                    cell.classList.remove('selected');
                    
                    if (cellRow <= this.selectedRows && cellCol <= this.selectedCols) {
                        cell.classList.add('selected');
                    }
                });
            }

            selectTableSize(rows, cols) {
                this.selectedRows = Math.max(1, Math.min(20, rows));
                this.selectedCols = Math.max(1, Math.min(20, cols));
                
                // Update input fields
                this.rowsInput.value = this.selectedRows;
                this.colsInput.value = this.selectedCols;
                
                this.highlightSelectedCells();
                this.updateTableInfo(this.selectedRows, this.selectedCols);
            }

            updateTableFromInputs() {
                const rows = Math.max(1, Math.min(20, parseInt(this.rowsInput.value) || 1));
                const cols = Math.max(1, Math.min(20, parseInt(this.colsInput.value) || 1));
                
                // Update inputs to ensure valid values
                this.rowsInput.value = rows;
                this.colsInput.value = cols;
                
                this.selectTableSize(rows, cols);
            }

            updateTableInfo(rows, cols) {
                this.tableInfo.textContent = `Select table size (${rows} √ó ${cols})`;
            }

            showTableDialog() {
                this.tableDialog.classList.add('show');
                document.body.style.overflow = 'hidden';
                
                // Reset to default values
                this.selectTableSize(3, 3);
                
                // Focus on rows input
                setTimeout(() => {
                    this.rowsInput.focus();
                    this.rowsInput.select();
                }, 100);
            }

            hideTableDialog() {
                this.tableDialog.classList.remove('show');
                document.body.style.overflow = '';
                
                // Return focus to editor
                this.editor.focus();
            }

            createTableFromDialog() {
                const rows = this.selectedRows;
                const cols = this.selectedCols;
                
                if (rows >= 1 && cols >= 1 && rows <= 20 && cols <= 20) {
                    const tableMarkdown = this.generateTableMarkdown(rows, cols);
                    this.insertTableAtCursor(tableMarkdown);
                    this.hideTableDialog();
                    this.updatePreview();
                }
            }

            generateTableMarkdown(rows, cols) {
                let markdown = '\n';
                
                // Generate header row
                const headers = Array.from({ length: cols }, (_, i) => `Header ${i + 1}`);
                markdown += '| ' + headers.join(' | ') + ' |\n';
                
                // Generate separator row
                const separators = Array.from({ length: cols }, () => '--------');
                markdown += '| ' + separators.join(' | ') + ' |\n';
                
                // Generate data rows
                for (let i = 0; i < rows - 1; i++) {
                    const cells = Array.from({ length: cols }, (_, j) => `Cell ${i + 1}-${j + 1}`);
                    markdown += '| ' + cells.join(' | ') + ' |\n';
                }
                
                markdown += '\n';
                return markdown;
            }

            insertTableAtCursor(tableMarkdown) {
                const start = this.editor.selectionStart;
                const end = this.editor.selectionEnd;
                
                // Get the text before and after cursor
                const textBefore = this.editor.value.substring(0, start);
                const textAfter = this.editor.value.substring(end);
                
                // Check if we need to add extra newlines for proper formatting
                let prefix = '';
                let suffix = '';
                
                // Add newline before if cursor is not at start of line or after whitespace
                if (textBefore.length > 0 && !textBefore.endsWith('\n')) {
                    prefix = '\n';
                }
                
                // Add newline after if there's text after cursor and it doesn't start with newline
                if (textAfter.length > 0 && !textAfter.startsWith('\n')) {
                    suffix = '\n';
                }
                
                const finalTable = prefix + tableMarkdown + suffix;
                
                // Insert the table
                this.editor.value = textBefore + finalTable + textAfter;
                
                // Position cursor after the table
                const newCursorPos = start + finalTable.length;
                this.editor.setSelectionRange(newCursorPos, newCursorPos);
                this.editor.focus();
            }

            handleKeyDown(e) {
                // Handle keyboard shortcuts
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key) {
                        case 'b':
                            e.preventDefault();
                            this.executeAction('bold');
                            break;
                        case 'i':
                            e.preventDefault();
                            this.executeAction('italic');
                            break;
                        case 'k':
                            e.preventDefault();
                            this.executeAction('link');
                            break;
                        case 't':
                            e.preventDefault();
                            this.showTableDialog();
                            break;
                    }
                }

                // Handle Enter key for line breaks
                if (e.key === 'Enter') {
                    this.handleEnterKey(e);
                }

                // Handle Tab key for indentation
                if (e.key === 'Tab') {
                    e.preventDefault();
                    this.insertAtCursor('    '); // 4 spaces
                }
            }

            handleEnterKey(e) {
                // For now, let default behavior handle Enter
                // We'll enhance this for smart list continuation later
            }

            handlePaste(e) {
                // Handle paste events - could add smart paste detection later
            }

            executeAction(action, element, options = {}) {
                const start = this.editor.selectionStart;
                const end = this.editor.selectionEnd;
                const selectedText = this.editor.value.substring(start, end);
                let replacement = '';

                switch(action) {
                    case 'heading':
                        const level = options.level || 1;
                        replacement = this.wrapWithHeading(selectedText, level);
                        break;
                    case 'bold':
                        replacement = this.wrapText(selectedText, '**', '**');
                        break;
                    case 'italic':
                        replacement = this.wrapText(selectedText, '*', '*');
                        break;
                    case 'strikethrough':
                        replacement = this.wrapText(selectedText, '~~', '~~');
                        break;
                    case 'unordered-list':
                        replacement = this.createList(selectedText, '-');
                        break;
                    case 'ordered-list':
                        replacement = this.createList(selectedText, '1.');
                        break;
                    case 'task-list':
                        replacement = this.createTaskList(selectedText);
                        break;
                    case 'link':
                        replacement = this.createLink(selectedText);
                        break;
                    case 'image':
                        replacement = this.createImage(selectedText);
                        break;
                    case 'table':
                        // Table creation is handled separately via dialog
                        return;
                    case 'code-block':
                        replacement = this.createCodeBlock(selectedText);
                        break;
                    case 'blockquote':
                        replacement = this.createBlockquote(selectedText);
                        break;
                    case 'horizontal-rule':
                        replacement = '\n\n---\n\n';
                        break;
                    case 'highlight':
                        replacement = this.wrapText(selectedText, '==', '==');
                        break;
                }

                if (replacement) {
                    this.replaceSelection(replacement, start, end);
                    this.updatePreview();
                }
            }

            wrapWithHeading(text, level) {
                const hashes = '#'.repeat(level);
                if (text.includes('\n')) {
                    return text.split('\n').map(line => 
                        line.trim() ? `${hashes} ${line.trim()}` : line
                    ).join('\n');
                }
                return `${hashes} ${text || 'Heading'}`;
            }

            wrapText(text, before, after) {
                if (text) {
                    return `${before}${text}${after}`;
                }
                return `${before}text${after}`;
            }

            createList(text, marker) {
                if (text.includes('\n')) {
                    return text.split('\n').map(line => 
                        line.trim() ? `${marker} ${line.trim()}` : line
                    ).join('\n');
                }
                return `${marker} ${text || 'List item'}`;
            }

            createTaskList(text) {
                if (text.includes('\n')) {
                    return text.split('\n').map(line => 
                        line.trim() ? `- [ ] ${line.trim()}` : line
                    ).join('\n');
                }
                return `- [ ] ${text || 'Task item'}`;
            }

            createLink(text) {
                const linkText = text || 'Link text';
                return `[${linkText}](https://example.com)`;
            }

            createImage(text) {
                const altText = text || 'Alt text';
                return `![${altText}](image.jpg)`;
            }

            createCodeBlock(text) {
                if (text) {
                    return `\`\`\`\n${text}\n\`\`\``;
                }
                return `\`\`\`javascript\n// Your code here\nconsole.log('Hello World');\n\`\`\``;
            }

            createBlockquote(text) {
                if (text.includes('\n')) {
                    return text.split('\n').map(line => 
                        line.trim() ? `> ${line.trim()}` : '>'
                    ).join('\n');
                }
                return `> ${text || 'Quote text'}`;
            }

            insertAtCursor(text) {
                const start = this.editor.selectionStart;
                const end = this.editor.selectionEnd;
                this.replaceSelection(text, start, end);
            }

            replaceSelection(replacement, start, end) {
                const value = this.editor.value;
                const newValue = value.substring(0, start) + replacement + value.substring(end);
                this.editor.value = newValue;
                
                // Set cursor position after replacement
                const newCursorPos = start + replacement.length;
                this.editor.setSelectionRange(newCursorPos, newCursorPos);
                this.editor.focus();
            }

            toggleDropdown(dropdownId) {
                this.hideDropdowns();
                const dropdown = document.getElementById(dropdownId);
                if (dropdown) {
                    dropdown.classList.toggle('show');
                }
            }

            hideDropdowns() {
                document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                    dropdown.classList.remove('show');
                });
            }

            updatePreview() {
                const markdownText = this.editor.value;
                
                try {
                    // Process the markdown with enhanced features
                    let html = marked.parse(markdownText);
                    
                    // Add support for highlighting (==text==)
                    html = html.replace(/==(.*?)==/g, '<mark>$1</mark>');
                    
                    // Add support for subscript (H~2~O)
                    html = html.replace(/~(.*?)~/g, '<sub>$1</sub>');
                    
                    // Add support for superscript (X^2^)
                    html = html.replace(/\^(.*?)\^/g, '<sup>$1</sup>');
                    
                    this.preview.innerHTML = html;
                } catch (error) {
                    console.error('Error parsing markdown:', error);
                    this.preview.innerHTML = '<p>Error parsing markdown</p>';
                }
            }

            updateStats() {
                const text = this.editor.value;
                const words = text.trim() ? text.trim().split(/\s+/).length : 0;
                const chars = text.length;
                const lines = text.split('\n').length;

                this.wordCount.textContent = `${words} words`;
                this.charCount.textContent = `${chars} characters`;
                this.lineCount.textContent = `${lines} lines`;
            }

            // Public method to set content
            setContent(markdown) {
                this.editor.value = markdown;
                this.updatePreview();
                this.updateStats();
            }

            // Public method to get content
            getContent() {
                return this.editor.value;
            }

            // Public method to get HTML
            getHTML() {

                return this.preview.innerHTML;
            }
            // Public method to set content
            setMarkdownContent(content) {
                this.editor.value = content;
                this.updatePreview();
                this.updateStats();
            }
        }

        // Initialize the editor when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.markdownEditor = new EmbeddedMarkdownEditor();

        });
    </script>